#lang pie
; https://github.com/funexists/2025-stellenbosch/blob/main/Chapter7.md
;-------------------------------------------------------------------------------
; Functions from previous exercises

(claim step+ (-> Nat Nat Nat))
(define step+
  (λ(_n-1 a-n-1)
    (add1 a-n-1)))

(claim + (-> Nat Nat Nat))
(define +
  (λ(a b) (rec-Nat a b step+)))

(claim predecessor (-> Nat Nat))
(define predecessor (λ(n) (which-Nat n 0 (λ(n-1) n-1))))

(claim - (-> Nat Nat Nat))
(define - (λ(a b) (rec-Nat b a (λ(b-1 a-b-1) (predecessor a-b-1)))))

; Some sample data
(claim vec-nats (Vec Nat 3))
(define vec-nats (vec:: 10 (vec:: 20 (vec:: 30 vecnil))))
(claim vec-nats-2 (Vec Nat 3))
(define vec-nats-2 (vec:: 1 (vec:: 2 (vec:: 3 vecnil))))

;-------------------------------------------------------------------------------
; Exercise 7.0
; ------------
; Define a function called zip that takes an argument of type (Vec A n) and
; a second argument of type (Vec B n) and evaluates to a value of type
; (Vec (Pair A B) n), the result of zipping the first and second arguments.

; Answer
; -----

; The idea is that we have a function f(a,b) -> v
; f(h_a::t_a,h_b::t_b) = p(h_a,h_b)::f(t_a,t_b)
; f_n = p(h_n,h_n)::f_n-1(t_n,t_n)

(claim VecPair (-> U U Nat U))
(define VecPair (λ(A B n) (Vec (Pair A B) n)))

(claim mot-zip (-> U U Nat U))
(define mot-zip (λ(A B n) (-> (Vec A n) (Vec B n) (VecPair A B n))))

; Start by considering the base
(claim base-zip
  (Pi ((A U) (B U))
    (mot-zip A B zero)))
(define base-zip
  (λ(_A _B)
    (λ(_va _vb) vecnil)))

(claim step-zip
  (Pi ((A U) (B U) (n-1 Nat))
    (-> (mot-zip A B n-1) (mot-zip A B (add1 n-1)))))

(define step-zip
  (λ(_A _B _n-1 fn-1)
    (λ(va vb)
      (vec::
        (cons (head va) (head vb))
        (fn-1 (tail va) (tail vb))))))

(claim zip
  (Pi((A U) (B U)(n Nat))
    (-> (Vec A n) (Vec B n) (VecPair A B n))))

(define zip
  (λ(A B n)
    (ind-Nat n
      (mot-zip A B)
      (base-zip A B)
      (step-zip A B))))


(check-same (Vec (Pair Nat Nat) 3)
  (zip Nat Nat 3 vec-nats vec-nats)
  (vec:: (cons 10 10) (vec:: (cons 20 20) (vec:: (cons 30 30) vecnil))))

;-------------------------------------------------------------------------------
; Exercise 7.1
; ------------
; Define a function called append that takes an argument of type (Vec E m) and
; an argument of type (Vec E n) and evaluates to a value of type (Vec (+ m n)),
; the result of appending the elements of the second argument to the end of
; the first.


; Answer
; ------
; Define prepend(a,b)
; Then append(a,b) = prepend(b,a)
; it reverses the arguments of prepend

(claim mot-prepend (-> U Nat Nat U))
(define mot-prepend
  (λ(E m n)
    (-> (Vec E m) (Vec E n) (Vec E (+ n m)))))

(claim base-prepend
  (Pi ((E U) (m Nat))
    (mot-prepend E m zero)))
(define base-prepend
  (λ(_E _m)
    (λ(vm _vn) vm)))

(claim step-prepend
  (Pi((E U) (m Nat) (n-1 Nat))
    (-> (mot-prepend E m n-1) (mot-prepend E m (add1 n-1)))))

(define step-prepend
  (λ(_E _m _n-1 fn-1)
    (λ(vm vn)
      (vec:: (head vn) (fn-1 vm (tail vn))))))

(claim prepend
  (Pi((E U) (m Nat) (n Nat))
    (-> (Vec E m) (Vec E n) (Vec E (+ n m)))))

(define prepend
  (λ(E m n)
    ; although one can possibly exchange arguments here
    ; I just found is easier to avoid that trick while
    ; trying to understand the material
    (ind-Nat n
      (mot-prepend E m)
      (base-prepend E m)
      (step-prepend E m))))

(claim append
  (Pi((E U) (m Nat) (n Nat))
    (-> (Vec E m) (Vec E n) (Vec E (+ m n)))))
(define append
  (λ(E m n va vb) (prepend E n m vb va)))

(check-same (Vec Nat 6)
  (append Nat 3 3 vec-nats vec-nats-2)
  (vec:: 10 (vec:: 20 (vec:: 30 (vec:: 1 (vec:: 2 (vec:: 3 vecnil)))))))




#lang pie
;-------------------------------------------------------------------------------
; From previous chapters

(claim length (Pi ((E U)) (-> (List E) Nat)))
(define length
  (λ(_E) (λ(a) (rec-List a zero (λ(_e _t a-t) (add1 a-t))))))

(claim step+ (-> Nat Nat Nat))
(define step+ (λ(_n-1 +n-1) (add1 +n-1)))
(claim + (-> Nat Nat Nat))
(define + (λ(a b) (rec-Nat a b step+)))

(claim append (Pi((E U)) (-> (List E) (List E) (List E))))
(claim step-append (Pi((E U)) (-> E (List E) (List E) (List E))))

(define step-append
  (λ(_E)
    (λ(h _t a-t) (:: h a-t))))
(define append (λ(E) (λ(a b) (rec-List a b (step-append E)))))

(claim plus-assoc
  (Pi ((n Nat) (m Nat) (k Nat))
    (= Nat (+ k (+ n m)) (+ (+ k n) m))))
(define plus-assoc
  (λ(n m k)
    (ind-Nat k
      ; proposition:  k + (n + m) =  (k + n) + m
      (λ(k) (= Nat (+ k (+ n m)) (+ (+ k n) m)))
      ; 0 + (n + m) = (0 + n) + m
      (same (+ n m))
      ;        k+1 + (n + m) =     (k+1 + n) + m
      ; => 1 + (k + (n + m)) = 1 + (k + n) + m
      (λ(_k-1 fk-1) (cong fk-1 (+ 1)))
      )))

;-------------------------------------------------------------------------------
; From chapter 10

(the (Sigma ((x Atom)) (= Atom x x))
  (cons 'one
    (same 'one)))

; there exists an l
(Sigma ((l Nat)) (Vec Atom l))
; for every l
(Pi((l Nat)) (Vec Atom l))

; for every E and l we can convert a list to a Vec
(Pi((E U) (l Nat)) (-> (List E) (Vec E l)))

; Possible statements to map list to vec
; For every E there exists an l such that we can convert a list to a vec
; (Pi((E U)) (Sigma ((l Nat)) (-> (List E) (Vec E l))))
; There exists an l such that for any E we can convert a list to a vec
; (Sigma ((l Nat)) (Pi((E U))  (-> (List E) (Vec E l))))
; For every E map the list to a vector with some l as length
; (Pi((E U)) (-> (List E) (Sigma ((l Nat)) (Vec E l))))

; produce a vec of length l that contains the same element e
(claim replicate (Pi ((E U) (l Nat)) (-> E (Vec E l))))

(define replicate
  (λ(E l e)
    (ind-Nat l
      ; motive
      (λ(n) (Vec E n))
      ; base
      vecnil
      (λ(_l-1 a-l-1)
        (vec:: e a-l-1))
      )
    )
  )

(length Nat nil)

; for every list of E map it to a vector of the same length
(claim list->vec
  (Pi((E U) (lst (List E))) (Vec E (length E lst))))

(define list->vec
  (λ(E lst)
    ; we have dependent type; so we use ind
    (ind-List
      ; target -- induction on lst
      lst
      ; motive -- what we want to get
      (λ(lst) (Vec E (length E lst)))
      ; base -- empty list
      vecnil
      ; step -- h, tail-1 and answer of tail-1 -> answer of tail
      (λ(h _tail-1 a-tail-1)
        (vec:: h a-tail-1)
        )
      )
    )
  )

;-------------------------------------------------------------------------------
; Exercise 10.1
; -------------
; Define a function called list-length-append-dist that states and proves that
; if you append two lists, l1 and l2, and then the length of the result is
; equal to the sum of the lengths of l1 and l2.

(claim list-length-append-dist
  (Pi((E U) (l1 (List E)) (l2 (List E)))
    (= Nat (length E (append E l1 l2))
       (+ (length E l1) (length E l2)))))
(define list-length-append-dist
  (λ(E l1 l2)
    (ind-List l1
      (λ(lst)
        (= Nat (length E (append E lst l2)) (+ (length E lst) (length E l2)))
        )
      (same (length E l2))
      (λ(_h _lst-1 a-lst-1)
        (cong a-lst-1 (+ 1))
        )
      )
    )
  )

;-------------------------------------------------------------------------------
; Exercise 10.2
; -------------
; In the following exercises we'll use the function called <= that takes two
; Nat arguments a, b and evaluates to a type representing the proposition that a
; is less than or equal to b.

(claim <= (-> Nat Nat U))
; for all a b there is some k such that a+k = b
(define <= (λ (a b) (Σ ([k Nat]) (= Nat (+ k a) b))))

; Exercise 10.2.1
; ---------------
; Using <=, state and prove that 1 is less than or equal to 2.

(claim 1<=2 (<= 1 2))
(define 1<=2 (cons 1 (same 2)))

;-------------------------------------------------------------------------------
; Exercise 10.2.2
; ---------------
; Define a function called <=-simplify to state and prove that for all Nats a,
; b, n we have that n+a <= b implies a <= b
;
; NB: You may need to use plus-assoc that was proved in Exercise 8.3.

; Conceptual:
;    n + a <= b -> a <= b because if we subtract n from lhs becomes even smaller

; Show that
; a <= a + 1
(claim a<=a+1 (Pi((a Nat)) (<= a (add1 a))))
(define a<=a+1
  (λ(a)
    (the (<= a (add1 a))
      ; (a+1) + k = (a+1) + 1 when k = 1
      (cons
        1
        ; a+1 = a+1
        (same (add1 a)))
      )
    )
  )

; Show that
;   a+1 <= b -> a <= b
; Conceptual:
;               1 + a <= b      .. A (given)
;    Σ k1 k1 + (1 + a) = b        .. B Expand A
;         k1 + (1 + a) = (k1 + 1) + a  .. C assoc 1 a k
;    Σ k1 (k1 + 1) + a) = b   .. D C into B
;           Σ k2 k2 + a = b   .. E G with k2 = add1 k1
;                   a <= b    .. F E and definition of <=


(claim a+1<=b->a<=b
  (Pi ((a Nat) (b Nat))
    (-> (<= (add1 a) b) (<= a b))
    )
  )

(define a+1<=b->a<=b
  (λ(a b)
    (λ(1+a<=b)
      ; (1 + k1) + a = b?
      TODO
      #| (replace |#
      #|   (plus-assoc a (car 1+a<=b) 1) |#
      #|   (λ(k) (<= k b)) |#
      #|   ; k1 + (1 + a) = b |#
      #|   1+a<=b |#
      #|   ) |#
      )
    )
  )


(claim n+a<=b->a<=b
  (Pi((a Nat) (b Nat) (n Nat)) (-> (<= (+ n a) b) (<= a b))))

; The straight forward approach does not work
(define n+a<=b->a<=b
  (λ(a b n n+a<=b)
    TODO
    )
  )

(claim mot-<=-simp (-> Nat Nat Nat U))
(define mot-<=-simp
  (λ(a b n) (-> (<= (+ n a) b) (<= a b)))
  )

(claim base-<=simp (Pi((a Nat) (b Nat)) (mot-<=-simp a b zero)))
(define base-<=simp
  (λ(a b)
    (the (-> (<= (+ zero a) b) (<= a b))
      (λ(pre) pre)
      )
    )
  )

(claim step-<=simp
  (Pi((a Nat) (b Nat) (n Nat))
    (-> (mot-<=-simp a b n)
      (mot-<=-simp a b (add1 n)))
    )
  )
(define step-<=simp
  ; (Σ k : k + (n+1 + a) = b)) -> (Σ k k + a = b)
  ; (Σ k : k + add1(n + a) = b)) -> (Σ k k + a = b)
  (λ(a b n n+a<=b->a<=b)
    ; almost right
    ; (Σ k : k + (n + a) = b)) -> (Σ k k + a = b)
    ; n+a<=b->a<=b
    ; Can we can try to show that
    ; a+1<b->a<=b
    ; (Σ k k + add1(a) = b) -> (Σ k k + a = b)
    ; No: does not help -- it is what we try to show
    ; We have A -> B; we want A+ where A -> A+ -> B
    TODO
    )
  )
